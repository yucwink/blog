"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[477],{2679:(e,a,s)=>{s.r(a),s.d(a,{comp:()=>r,data:()=>i});var p=s(641);const n={},r=(0,s(6262).A)(n,[["render",function(e,a){return(0,p.uX)(),(0,p.CE)("div",null,a[0]||(a[0]=[(0,p.Fv)('<p>高可用：自动重启 自动修复</p><p>可扩展性：根据负载变化动态改变资源</p><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><h3 id="_1-node-节点或者物理机" tabindex="-1"><a class="header-anchor" href="#_1-node-节点或者物理机"><span>1.node-节点或者物理机</span></a></h3><ul><li><p>Node是一个运行着Kubernetes节点软件的物理机器或虚拟机。</p></li><li><p>Node是Kubernetes集群中的工作节点， 它实际执行应用程序工作负载并提 供运行环境。</p></li></ul><h3 id="_2-pod-最小调度单元-容器的抽象" tabindex="-1"><a class="header-anchor" href="#_2-pod-最小调度单元-容器的抽象"><span>2.pod-最小调度单元，容器的抽象</span></a></h3><ul><li><p>Pod 是 Kubernetes中最小的可部署单元</p></li><li><p>一个 Pod 可以包含一个或多个紧密关联的容器，它们共享相同的网络命名空间、 IP 地址和存储卷， 并在同一个宿主机上运行。</p><p>pod发生故障k8s自动销毁，创建新的pod替代 但是ip会变化，此时需要service</p></li></ul><h3 id="_3-service-将一组pod封装成一个服务-并提供统一入口访问" tabindex="-1"><a class="header-anchor" href="#_3-service-将一组pod封装成一个服务-并提供统一入口访问"><span>3.service-将一组pod封装成一个服务，并提供统一入口访问</span></a></h3><ul><li><p>Service 是将运行在一个或一组 Pod 上的网络应用程序公开为网络服务的方法。</p></li><li><p>实现方式，将应用程序的pod封装成两个service，这样可以通过service的ip地址访问该应用，即使pod的ip地址发生变化，但是service的地址并不会变化。service自动将请求转发到其他健康的pod上，这样解决了pod的ip地址不稳定问题</p></li></ul><h4 id="内部服务和外部服务" tabindex="-1"><a class="header-anchor" href="#内部服务和外部服务"><span>内部服务和外部服务</span></a></h4><p>内部：集群内布服务 mysql 缓存 消息队列</p><p>外部：暴露给外部 前端程序</p><ul><li>node:port 再节点上开放一个端口，将这个端口映射到Service的IP地址和端口上，通过节点的ip地址和端口访问service</li></ul><h3 id="_4-ingress-将外部请求转发到内部的集群和service上" tabindex="-1"><a class="header-anchor" href="#_4-ingress-将外部请求转发到内部的集群和service上"><span>4.ingress-将外部请求转发到内部的集群和service上</span></a></h3><p>在生产上用域名 使用ingress,用来管理从集群外部访问集群内部服务的入口和方式，通过ingress配置不同的转发规则，根据不同的规则访问不同的service和对应的pod 还可以给ingress配置域名、负载均衡等</p><h3 id="_5-configmap-配置信息" tabindex="-1"><a class="header-anchor" href="#_5-configmap-配置信息"><span>5.configMap-配置信息</span></a></h3><p>将配置信息封装起来，让应用可以读取configMap中的配置信息</p><p>配置需要调整，修改configMap重新加载pod即可 应用程序和配置的解耦 但是明文存储</p><h3 id="_6-sercet-铭感信息" tabindex="-1"><a class="header-anchor" href="#_6-sercet-铭感信息"><span>6.sercet-铭感信息</span></a></h3><p>做了base64编码</p><p>还需配合其它安全机制，例如网络安全、访问控制、身份认证</p><h3 id="_7-volumes-数据挂载-实现集群中数据的持久化部署" tabindex="-1"><a class="header-anchor" href="#_7-volumes-数据挂载-实现集群中数据的持久化部署"><span>7.Volumes-数据挂载，实现集群中数据的持久化部署</span></a></h3><p>将持久化数据挂载到本地的磁盘或者集群外部的远程存储上，即使容器被销毁和重启，数据仍不会消失</p><h3 id="_8-deployment-部署无状态应用程序" tabindex="-1"><a class="header-anchor" href="#_8-deployment-部署无状态应用程序"><span>8.deployment-部署无状态应用程序</span></a></h3><p>解决当一个节点故障时，service自动将请求转发到另外的节点上来提供服务</p><p>定义和管理应用程序的副本数量和应用程序的更新策略（滚动更新，例如版本升级策略）</p><h3 id="_9-statefulset-部署有状态应用程序" tabindex="-1"><a class="header-anchor" href="#_9-statefulset-部署有状态应用程序"><span>9.StatefulSet-部署有状态应用程序</span></a></h3><p>因为数据库的多副本之前是有状态的，所以使用StatefulSet</p><p>有状态和保留应用状态的一般使用这个</p>',29)]))}]]),i=JSON.parse('{"path":"/article/tyntnwpa/","title":"kubernetes","lang":"zh-CN","frontmatter":{"title":"kubernetes","createTime":"2025/05/14 00:27:11","permalink":"/article/tyntnwpa/"},"headers":[],"readingTime":{"minutes":2.63,"words":790},"git":{"updatedTime":1747158862000,"contributors":[{"name":"yuc","username":"yuc","email":"1120062005@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yuc?v=4","url":"https://github.com/yuc"}]},"filePathRelative":"notes/kubernetes/kubernetes.md","categoryList":[{"id":"4358b5","sort":10001,"name":"notes"},{"id":"7c99e0","sort":10002,"name":"kubernetes"}]}')}}]);